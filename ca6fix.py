#!/usr/bin/python3

# Copyright (c) 2021 Kazuki Ohara
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
from PyPDF4 import pdf, PdfFileReader, PdfFileWriter

outline = [
    ['表表紙', -21],
    ['扉', -20],
    ['版権', -19],
    ['献辞', -18],
    ['チューリング賞受賞の著者', -16],
    ['序文 [Norman P. Jouppi, Google]', -15],
    ['推薦の言葉', -14],
    ['まえがき', -13, [
        ['我々がこの本を書いた理由', -13],
        ['この版について', -13],
        ['話題の選択と構成', -13],
        ['内容の概観', -12],
        ['この教科書の読み方', -11],
        ['章構成', -11],
        ['ケーススタディと演習問題', -11],
        ['補助的な記述部分', -10],
        ['本書改善の手助けのお願い', -10],
        ['おわりに', -10]
    ]],
    ['謝辞', -9, [
        ['第6版の貢献者', -9],
        ['旧版の貢献者', -8],
    ]],
    ['目次', -5],
    ['1 定量的な設計と解析の基礎', 1, [
        ['1.1 はじめに', 1],
        ['1.2 コンピュータのクラス', 3, [
            ['1.2.1 Internet of Things/組み込みコンピュータ', 3],
            ['1.2.2 パーソナルモバイルデバイス', 4],
            ['1.2.3 デスクトップコンピューティング', 4],
            ['1.2.4 サーバ', 5],
            ['1.2.5 クラスタ/ウェアハウススケールコンピュータ', 5],
            ['1.2.6 並列性のクラスと並列アーキテクチャ', 5]
        ]],
        ['1.3 コンピュータアーキテクチャを設計する', 6, [
            ['1.3.1 命令セットアーキテクチャ:コンピュータアーキテクチャの表層的な見方', 6],
            ['1.3.2 正統的なコンピュータアーキテクチャ:構成とハードウェアを、目標と機能的要求を満足するように設計する', 9]
        ]],
        ['1.4 テクノロジのトレンド', 10, [
            ['1.4.1 性能のトレンド:レイテンシを上回るバンド幅', 11],
            ['1.4.2 トランジスタ性能と配線のスケーリング', 12]
        ]],
        ['1.5 半導体の電力とエネルギーのトレンド', 13, [
            ['1.5.1 電力とエネルギー:システム面', 13],
            ['1.5.2 マイクロプロセッサのエネルギーと電力', 14],
            ['1.5.3 エネルギーの限界によるコンピュータアーキテクチャの移り変わり', 15]
        ]],
        ['1.6 コストのトレンド', 16, [
            ['1.6.1 時間、量、標準部品化のインパクト', 16],
            ['1.6.2 集積回路のコスト', 17],
            ['1.6.3 コストと価格', 19],
            ['1.6.4 製造コスト対運用コスト', 19]
        ]],
        ['1.7 確実性', 19],
        ['1.8 性能の測定、報告、整理の方法', 20,[
            ['1.8.1 ベンチマーク', 21],
            ['1.8.2 性能評価の結果の報告', 24],
            ['1.8.3 性能評価のまとめ方', 24]
        ]],
        ['1.9 コンピュータ設計の定量的な原則', 25,[
            ['1.9.1 並列性を利用せよ', 25],
            ['1.9.2 局所性の原則', 26],
            ['1.9.3 共通の場合に集中せよ', 26],
            ['1.9.4 Amdahlの法則', 26],
            ['1.9.5 プロセッサの性能式', 27]
        ]],
        ['1.10 総合的な実例:性能、価格、電力', 29],
        ['1.11 誤った考えと落とし穴', 31],
        ['1.12 おわりに', 33],
        ['1.13 歴史展望と参考文献', 35],
        ['1.14 ケーススタディと演習問題', 35, [
            ['ケーススタディ1:製造コスト', 35],
            ['ケーススタディ2:コンピュータシステムの消費電力', 35],
            ['演習問題', 37]
        ]],
    ]],
    ['2 メモリ階層の設計', 41, [
        ['2.1 はじめに', 41, [
            ['2.1.1 メモリ階層の基本:簡単なおさらい', 43]
        ]],
        ['2.2 メモリ技術と最適化', 45, [
            ['2.2.1 SRAMテクノロジ', 45],
            ['2.2.2 DRAMテクノロジ', 45],
            ['2.2.3 DRAMチップ内での性能の改善:SDRAM', 46],
            ['2.2.4 グラフィックデータ用DRAM', 48],
            ['2.2.5 パッケージの技術革新:積層DRAMと組み込みDRAM', 48],
            ['2.2.6 フラッシュメモリ', 48],
            ['2.2.7 相変化メモリ技術', 49],
            ['2.2.8 メモリのディペンダビリティの向上', 49]
        ]],
        ['2.3 キャッシュの性能を向上させる10の高度な改良法', 50],
        ['2.4 保護:仮想メモリと仮想マシン', 61, [
            ['2.4.1 仮想メモリを通じた保護', 62],
            ['2.4.2 仮想マシンを用いた保護', 62],
            ['2.4.3 仮想マシンモニタの要求', 63],
            ['2.4.4 仮想マシンを支援する命令セットアーキテクチャ', 63],
            ['2.4.5 仮想メモリとI/O上の仮想マシンの影響', 64],
            ['2.4.6 効率的な仮想化とセキュリティの向上のための命令セット拡張', 64],
            ['2.4.7 VMMの例:Xen仮想マシン', 65]
        ]],
        ['2.5 他の章との関連:メモリ階層の設計', 66, [
            ['2.5.1 保護、仮想化と命令セットアーキテクチャ', 66],
            ['2.5.2 自律的命令フェッチユニット', 66],
            ['2.5.3 投機的実行とメモリアクセス', 66],
            ['2.5.4 特殊な命令キャッシュ', 66],
            ['2.5.5 キャッシュされたデータの一貫性', 66]
        ]],
        ['2.6 総合的な実例:ARM Cortex-A53とIntel Core i7 6700のメモリ階層', 67, [
            ['2.6.1 ARM Cortex-A53', 67],
            ['2.6.2 Cortex-A53メモリ階層の性能', 68],
            ['2.6.3 Intel Core i7', 69]
        ]],
        ['2.7 誤った考えと落とし穴', 74],
        ['2.8 おわりに:将来予測', 76],
        ['2.9 歴史展望と参考文献', 77],
        ['2.10 ケーススタディと演習問題', 77, [
            ['ケーススタディ1:最新技術によるキャッシュの性能改善', 77],
            ['ケーススタディ2:総合的な実例:高並列メモリシステム', 78],
            ['ケーススタディ3:さまざまなメモリシステムの構成の影響を調べる', 80],
            ['演習問題', 81]
        ]]
    ]],
    ['3 命令レベル並列性とその活用', 87, [
        ['3.1 命令レベル並列性:概念とチャレンジ', 87, [
            ['3.1.1 命令レベル並列性とは何か', 88],
            ['3.1.2 データ依存とハザード', 88],
            ['3.1.3 制御依存', 90]
        ]],
        ['3.2 命令レベル並列性技術のためのコンパイラの基本', 91, [
            ['3.2.1 基本的なパイプラインスケジューリングとループアンローリング', 91],
            ['3.2.2 ループアンローリングとスケジューリングのまとめ', 93]
        ]],
        ['3.3 進んだ分岐予測による分岐コストの削減', 94, [
            ['3.3.1 相関を利用する分岐予測', 94],
            ['3.3.2 トーナメント予測:ローカル予測とグローバル予測を適切に組み合わせる方式', 96],
            ['3.3.3 TAGE(タグ付きハイブリッド予測器)', 96],
            ['3.3.4 Intel Core i7分岐予測の進歩', 98]
        ]],
        ['3.4 動的スケジューリングによるデータハザードの克服', 98, [
            ['3.4.1 動的スケジューリング:その発想', 99],
            ['3.4.2 Tomasuloのアプローチを用いる動的スケジューリング', 100]
        ]],
        ['3.5 動的スケジューリング:例題とアルゴリズム', 103, [
            ['3.5.1 Tomasuloアルゴリズムの詳細', 105],
            ['3.5.2 Tomasuloアルゴリズム:ループベースの例', 106]
        ]],
        ['3.6 ハードウェアベースの投機処理', 107],
        ['3.7 複数命令発行と静的スケジューリングを用いた命令レベル並列性の抽出', 113, [
            ['3.7.1 基本的なVLIWプロセッサのアプローチ', 113]
        ]],
        ['3.8 動的スケジューリング、複数命令発行および投機処理を用いた命令レベル並列性の抽出', 115],
        ['3.9 命令供給と投機処理のための高度な技術', 119, [
            ['3.9.1 命令フェッチバンド幅の改良', 119],
            ['3.9.2 特殊な分岐の予測器:予測手続きリターン、間接ジャンプ、およびループ分岐', 121],
            ['3.9.3 投機処理:実装に関する検討項目および拡張', 121]
        ]],
        ['3.10 他の章との関連:ILPのアプローチとメモリシステム', 124, [
            ['3.10.1 「ハードウェアによる投機」対「ソフトウェアによる投機」', 124],
            ['3.10.2 投機実行とメモリシステム', 125]
        ]],
        ['3.11 マルチスレッディング:単一プロセッサスループット改善のためのスレッドレベル並列性抽出', 125, [
            ['3.11.1 スーパースカラプロセッサ上での同時マルチスレッディングの効果', 127],
        ]],
        ['3.12 総合的実例:ARM Cortex-A53とCore i7 6700', 128, [
            ['3.12.1 ARM Cortex-A53', 128],
            ['3.12.2 Intel Core i7', 130]
        ]],
        ['3.13 誤った考えと落とし穴', 133],
        ['3.14 おわりに:次は何か', 136],
        ['3.15 歴史展望と参考文献', 137],
        ['3.16 ケーススタディと演習問題', 137, [
            ['ケーススタディ:マイクロアーキテクチャ技法の影響', 137],
            ['演習問題', 141]
        ]]
    ]],
    ['4 ベクタ、SIMD、GPUにおけるデータレベル並列性', 145, [
        ['4.1 はじめに', 145],
        ['4.2 ベクタアーキテクチャ', 146, [
            ['4.2.1 RV64V拡張', 146],
            ['4.2.2 ベクタプロセッサはどのように動くのか:その一例', 148],
            ['4.2.3 ベクタ実行時間', 149],
            ['4.2.4 複数のレーン:1クロックサイクル当たり1要素を超えて', 150],
            ['4.2.5 ベクタ長レジスタ:32以外のループを取り扱う', 152],
            ['4.2.6 プレディケートレジスタ:ベクタループのIF文の制御', 152],
            ['4.2.7 メモリバンク:ベクタロード-ストアユニットへの帯域の確保', 153],
            ['4.2.8 ストライド:ベクタアーキテクチャにおける多次元配列処理', 154],
            ['4.2.9 ギャザーとスキャター:ベクタアーキテクチャでの疎行列の扱い', 154],
            ['4.2.10 ベクタアーキテクチャのプログラミング', 155]
        ]],
        ['4.3 マルチメディア向けSIMD拡張命令セット', 156, [
            ['4.3.1 マルチメディアSIMDアーキテクチャのプログラミング', 157],
            ['4.3.2 性能可視化のルーフラインモデル', 158]
        ]],
        ['4.4 グラフィック処理ユニット', 159, [
            ['4.4.1 GPUのプログラミング', 159],
            ['4.4.2 NVIDIA GPUの計算機械としての構造', 160],
            ['4.4.3 NVIDIA GPUの命令セットアーキテクチャ', 164],
            ['4.4.4 GPUにおける条件分岐', 166],
            ['4.4.5 NVIDIA GPUのメモリ構成', 168],
            ['4.4.6 Pascal GPUアーキテクチャにおける革新', 168],
            ['4.4.7 ベクタアーキテクチャとGPUの類似点と相違点', 170],
            ['4.4.8 マルチメディアSIMD計算機とGPUの類似点と相違点', 172],
            ['4.4.9 まとめ', 172]
        ]],
        ['4.5 ループレベル並列性の検出と増強', 173, [
            ['4.5.1 依存性の発見', 175],
            ['4.5.2 依存する計算の除去', 177]
        ]],
        ['4.6 他の章との関連', 177, [
            ['4.6.1 エネルギーとDLP:遅くて幅広と速くて幅狭', 177],
            ['4.6.2 バンクメモリとグラフィックメモリ', 177],
            ['4.6.3 ストライドアクセスとTLBミス', 178]
        ]],
        ['4.7 総合的な実例:組み込み対サーバGPU、およびTesla対Core i7', 178, [
            ['4.7.1 GPUとマルチメディアSIMD付きMIMDの比較', 178],
            ['4.7.2 比較結果の更新', 181]
        ]],
        ['4.8 誤った考えと落とし穴', 182],
        ['4.9 おわりに', 183],
        ['4.10 歴史展望と参考文献', 183],
        ['4.11 ケーススタディと演習問題', 183, [
            ['ケーススタディ:ベクタカーネルのベクタプロセッサやGPUでの実装', 183],
            ['演習問題', 185]
        ]]
    ]],
    ['5 スレッドレベル並列性', 189, [
        ['5.1 はじめに', 189, [
            ['5.1.1 マルチプロセッサアーキテクチャ:問題と解決策', 190],
            ['5.1.2 並列処理の目指すもの', 192]
        ]],
        ['5.2 集中共有メモリ型アーキテクチャ', 194, [
            ['5.2.1 マルチプロセッサのキャッシュコヒーレンス制御とは', 194],
            ['5.2.2 コヒーレンスを維持するための基本方式', 195],
            ['5.2.3 スヌープコヒーレンスプロトコル', 196],
            ['5.2.4 基本的な実装方法', 197],
            ['5.2.5 プロトコル例', 198],
            ['5.2.6 基本コヒーレンスプロトコルの拡張', 200],
            ['5.2.7 対称型共有メモリ型マルチプロセッサとスヌーププロトコルの限界', 201],
            ['5.2.8 スヌープキャッシュコヒーレンス制御の実現', 202]
        ]],
        ['5.3 対称型共有メモリ型マルチプロセッサの性能', 203, [
            ['5.3.1 実アプリケーション処理', 204],
            ['5.3.2 マルチプログラミングとOSのワークロード', 206],
            ['5.3.3 マルチプログラムとOSワークロードの性能', 207]
        ]],
        ['5.4 分散共有メモリとディレクトリベースコヒーレンス制御', 209, [
            ['5.4.1 ディレクトリベースのキャッシュコヒーレンスプロトコル:基本概念', 210],
            ['5.4.2 ディレクトリプロトコル実際例', 211]
        ]],
        ['5.5 同期:その基本', 213, [
            ['5.5.1 基本ハードウェアプリミティブ', 213],
            ['5.5.2 コヒーレンス制御を用いたロック機構の実現', 215]
        ]],
        ['5.6 メモリコンシステンシモデル:導入', 216, [
            ['5.6.1 プログラマからの見え方', 217],
            ['5.6.2 リラックスコンシステンシモデル:その基本とリリースコンシステンシ', 218]
        ]],
        ['5.7 他の章との関連', 219, [
            ['5.7.1 コンパイラによる最適化とコンシステンシモデル', 219],
            ['5.7.2 厳密なコンシステンシモデルにおける遅延隠蔽のための投機実行', 219],
            ['5.7.3 包含(Inclusion)とその実現', 220],
            ['5.7.4 マルチプロセッシングとマルチスレッドを用いた性能向上', 221]
        ]],
        ['5.8 総合的な実例:マルチコアプロセッサとその性能', 221, [
            ['5.8.1 マルチプログラムワークロードにおけるマルチコアベースのマルチプロセッサの性能', 221],
            ['5.8.2 さまざまなワークロードによるXeon MPのスケーラビリティ', 226],
            ['5.8.3 Intel Core i7 920マルチコアの性能とエネルギー効率', 227]
        ]],
        ['5.9 誤った考えと落とし穴', 228],
        ['5.10 マルチコアの性能向上の将来', 230],
        ['5.11 おわりに', 232],
        ['5.12 歴史展望と参考文献', 232],
        ['5.13 ケーススタディと演習問題', 233, [
            ['ケーススタディ1:シングルチップマルチコアマルチプロセッサ', 233],
            ['ケーススタディ2:単純なディレクトリベースのコヒーレンス制御', 235],
            ['ケーススタディ3:メモリコンシステンシ', 237],
            ['演習問題', 238]
        ]]
    ]],
    ['6 要求レベル並列性/データレベル並列性を利用したウェアハウススケールコンピュータ', 243, [
        ['6.1 はじめに', 243],
        ['6.2 ウェアハウススケールコンピュータのプログラミングモデルとワークロード', 246],
        ['6.3 ウェアハウススケールコンピュータのコンピュータアーキテクチャ', 249, [
            ['6.3.1 ストレージ', 250],
            ['6.3.2 WSCメモリ階層', 250]
        ]],
        ['6.4 ウェアハウススケールコンピュータの効率とコスト', 252, [
            ['6.4.1 WSCの効率測定', 253],
            ['6.4.2 WSCのコスト', 254]
        ]],
        ['6.5 クラウドコンピューティング:ユーティリティコンピューティングの復活', 256, [
            ['6.5.1 Amazon Webサービス', 257],
            ['6.5.2 AWSクラウドの規模', 260]
        ]],
        ['6.6 他の章との関連', 261, [
            ['6.6.1 WSCネットワーク上のボトルネックの回避', 261],
            ['6.6.2 サーバ内における効率的なエネルギー利用方法', 262]
        ]],
        ['6.7 総合的な実例:Google社のウェアハウススケールコンピュータ', 263, [
            ['6.7.1 Google WSCでの配電', 263],
            ['6.7.2 Google WSCの冷却', 263],
            ['6.7.3 Google WSCのラック', 265],
            ['6.7.4 Google WSCにおけるネットワーク関連', 265],
            ['6.7.5 Google WSCにおけるサーバ', 266],
            ['6.7.6 結論', 267]
        ]],
        ['6.8 誤った考えと落とし穴', 267],
        ['6.9 おわりに', 269],
        ['6.10 歴史展望と参考文献', 270],
        ['6.11 ケーススタディと演習問題', 270, [
            ['ケーススタディ1:ウェアハウススケールコンピュータの設計方針に影響を与える総所有コスト', 270],
            ['ケーススタディ2:WSCにおけるリソース割り当てとTCO', 271],
            ['演習問題', 272]
        ]]
    ]],
    ['7 領域特化アーキテクチャ', 281, [
        ['7.1 はじめに', 281],
        ['7.2 DSAのガイドライン', 282],
        ['7.3 領域の例:深層ニューラルネットワーク', 284, [
            ['7.3.1 DNNのニューロン', 284],
            ['7.3.2 学習と推論', 285],
            ['7.3.3 多層パーセプトロン(MLP)', 285],
            ['7.3.4 畳み込みニューラルネットワーク(CNN)', 286],
            ['7.3.5 リカレントニューラルネットワーク(RNN)', 287],
            ['7.3.6 バッチ', 288],
            ['7.3.7 量子化', 288],
            ['7.3.8 DNNのまとめ', 288]
        ]],
        ['7.4 GoogleのTensorプロセッシングユニット:推論データセンターの加速器', 289, [
            ['7.4.1 TPUの起源', 289],
            ['7.4.2 TPUアーキテクチャ', 289],
            ['7.4.3 TPUの命令セットアーキテクチャ', 290],
            ['7.4.4 TPUのマイクロアーキテクチャ', 290],
            ['7.4.5 TPUの実装', 291],
            ['7.4.6 TPUのソフトウェア', 292],
            ['7.4.7 TPUの改良', 292],
            ['7.4.8 まとめ:TPUはガイドラインにどう沿っているか', 293]
        ]],
        ['7.5 MicrosoftのCatapult:柔軟なデータセンターのアクセラレータ', 294, [
            ['7.5.1 Catapultの実装とアーキテクチャ', 294],
            ['7.5.2 Catapultのソフトウェア', 295],
            ['7.5.3 CatapultでのCNN', 295],
            ['7.5.4 Catapultでの検索高速化', 296],
            ['7.5.5 Catapult V1の配備', 297],
            ['7.5.6 Catapult V2', 298],
            ['7.5.7 まとめ:Catapultはガイドラインにどう沿っているか', 299]
        ]],
        ['7.6 IntelのCrest:学習向けデータセンターのアクセラレータ', 299],
        ['7.7 Pixel Visual Core:パーソナルモバイルデバイスのための画像処理ユニット', 300, [
            ['7.7.1 ISP:IPUの祖先のハードウェア実装版', 301],
            ['7.7.2 Pixel Visual Coreのソフトウェア', 301],
            ['7.7.3 Pixel Visual Coreの哲学', 30],
            ['7.7.4 Pixel Visual Coreのhalo', 302],
            ['7.7.5 Pixel Visual Coreのプロセッサ', 303],
            ['7.7.6 Pixel Visual Coreの命令セットアーキテクチャ', 303],
            ['7.7.7 Pixel Visual Coreの例', 303],
            ['7.7.8 Pixel Visual Coreのプロセッシングエレメント', 304],
            ['7.7.9 2次元のラインバッファとそのコントローラ', 304],
            ['7.7.10 Pixel Visual Coreの実装', 305],
            ['7.7.11 まとめ:Pixel Visual Coreはガイドラインにどのように沿っているか', 305]
        ]],
        ['7.8 他の章との関連', 306, [
            ['7.8.1 不均質性とSystem on a Chip(SoC)', 306],
            ['7.8.2 オープンな命令セット', 306]
        ]],
        ['7.9 総合的な実例:CPU、GPU、DNNアクセラレータの比較', 307, [
            ['7.9.1 性能:ルーフライン、応答時間、そしてスループット', 308],
            ['7.9.2 価格性能比、TCO、ワット当たりの性能', 310],
            ['7.9.3 CatapultとPixel Visual Coreの評価', 310]
        ]],
        ['7.10 誤った考えと落とし穴', 311],
        ['7.11 おわりに', 312],
        ['7.12 歴史展望と参考文献', 313],
        ['7.13 ケーススタディと演習問題', 313, [
            ['ケーススタディ:GoogleのTensorプロセッシングユニットと深層学習ネットワークのアクセラレーション', 313],
            ['演習問題', 316]
        ]]
    ]],
    ['付録A 命令セットの原理', 319, [
        ['A.1 はじめに', 319],
        ['A.2 命令セットアーキテクチャの分類', 320, [
            ['A.2.1 まとめ:命令セットアーキテクチャの分類', 322]
        ]],
        ['A.3 メモリアドレッシング', 322, [
            ['A.3.1 メモリアドレスの解釈', 322],
            ['A.3.2 アドレッシングモード', 323],
            ['A.3.3 ディスプレースメント(ベース相対)アドレッシングモード', 324],
            ['A.3.4 即値(リテラル)アドレッシングモード', 325],
            ['A.3.5 まとめ:メモリアドレッシング', 325]
        ]],
        ['A.4 オペランドタイプとオペランドサイズ', 325],
        ['A.5 命令セットにおける命令操作', 326],
        ['A.6 制御のための命令', 327, [
            ['A.6.1 制御命令のためのアドレッシングモード', 327],
            ['A.6.2 条件分岐における選択肢', 328],
            ['A.6.3 手続き呼び出しにおける選択肢', 328],
            ['A.6.4 まとめ:制御のための命令', 329]
        ]],
        ['A.7 命令セットのエンコード', 329, [
            ['A.7.1 RISCにおけるコードサイズの削減', 330],
            ['A.7.2 まとめ:命令セットのエンコード', 330]
        ]],
        ['A.8 他の章との関連:コンパイラの役割', 331],
        ['A.8.1 最近のコンパイラの構造', 331, [
            ['A.8.2 レジスタ割り付け', 332],
            ['A.8.3 最適化が性能に及ぼす影響', 332],
            ['A.8.4 コンパイラ技術がアーキテクトの意思決定に及ぼす影響', 333],
            ['A.8.5 コンパイラ作成者へのアーキテクトの支援', 333],
            ['A.8.6 マルチメディア命令へのコンパイラの支援(というより支援不足)', 334],
            ['A.8.7 まとめ:コンパイラの役割', 335]
        ]],
        ['A.9 総合的な実例:RISC-Vアーキテクチャ', 335, [
            ['A.9.1 RISC-V命令セットの構成', 335],
            ['A.9.2 RISC-Vのレジスタ', 336],
            ['A.9.3 RISC-Vのデータタイプ', 336],
            ['A.9.4 RISC-Vのデータ転送におけるアドレッシングモード', 336],
            ['A.9.5 RISC-Vの命令フォーマット', 336],
            ['A.9.6 RISC-Vのオペレーション', 337],
            ['A.9.7 RISC-Vの制御命令', 338],
            ['A.9.8 RISC-Vの浮動小数点演算', 339],
            ['A.9.9 RISC-V命令セットの使用', 340]
        ]],
        ['A.10 誤った考えと落とし穴', 340],
        ['A.11 おわりに', 342],
        ['A.12 歴史展望と参考文献', 342],
        ['A.13 演習問題', 342]
    ]],
    ['付録B メモリ階層の復習', 347, [
        ['B.1 はじめに', 347, [
            ['B.1.1 キャッシュ性能の復習', 348],
            ['B.1.2 メモリ階層における4つの疑問', 349],
            ['B.1.3 実例:Opteronのデータキャッシュ', 352]
        ]],
        ['B.2 キャッシュの性能', 354, [
            ['B.2.1 平均メモリアクセス時間とプロセッサ性能', 355],
            ['B.2.2 アウトオブオーダ実行プロセッサのミスペナルティ', 356]
        ]],
        ['B.3 6つの基本的なキャッシュ改良法', 358, [
            ['B.3.1 基本的なキャッシュ改良法のまとめ', 366]
        ]],
        ['B.4 仮想メモリ', 367, [
            ['B.4.1 メモリ階層に対する4つの問いへの再訪', 368],
            ['B.4.2 高速アドレス変換技術', 369],
            ['B.4.3 ページサイズの選択', 370],
            ['B.4.4 仮想メモリとキャッシュのまとめ', 370]
        ]],
        ['B.5 仮想メモリの保護とその例', 371, [
            ['B.5.1 プロセス保護', 372],
            ['B.5.2 セグメント化仮想メモリの例:Intel Pentiumの保護', 372],
            ['B.5.3 ページ化仮想メモリの例:64ビットOpteronメモリ管理', 374],
            ['B.5.4 まとめ:32ビットIntel Pentiumと64ビットAMD Opteronの保護機構比較', 376]
        ]],
        ['B.6 誤った考えと落とし穴', 376],
        ['B.7 おわりに', 377],
        ['B.8 歴史展望と参考文献', 377],
        ['B.9 演習問題', 377]
    ]],
    ['付録C パイプライン処理:基本および中間的な概念', 381, [
        ['C.1 はじめに', 381, [
            ['C.1.1 パイプライン処理とは何か', 381],
            ['C.1.2 RISC命令セットの基礎', 382],
            ['C.1.3 RISC命令セットのシンプルな実装例', 382],
            ['C.1.4 RISCプロセッサの古典的な5段パイプライン', 383],
            ['C.1.5 パイプラインの基本性能', 385]
        ]],
        ['C.2 パイプライン処理の主要な障害:パイプラインハザード', 385, [
            ['C.2.1 ストール時のパイプライン性能', 386],
            ['C.2.2 データハザード', 386],
            ['C.2.3 分岐ハザード', 389],
            ['C.2.4 予測による分岐コストの削減', 391],
            ['C.2.5 静的分岐予測', 391],
            ['C.2.6 動的分岐予測と分岐予測バッファ', 392]
        ]],
        ['C.3 パイプラインの実装法', 393, [
            ['C.3.1 RISC-Vの簡単な実装例', 393],
            ['C.3.2 RISC-Vの基本パイプライン', 395],
            ['C.3.3 RISC-Vパイプラインの制御信号の実装', 397],
            ['C.3.4 パイプラインでの分岐の扱い', 399]
        ]],
        ['C.4 何がパイプラインの実装を困難にするのか', 399, [
            ['C.4.1 例外への対処', 399],
            ['C.4.2 命令セットの複雑さ', 402]
        ]],
        ['C.5 複数サイクル演算を扱うためのRISC-V整数パイプライン拡張', 403, [
            ['C.5.1 レイテンシの長いパイプラインにおけるハザードとフォワーディング', 405],
            ['C.5.2 正確な例外の維持', 407],
            ['C.5.3 RISC-V FPパイプラインの性能', 408]
        ]],
        ['C.6 総合的な実例:MIPS R4000パイプライン', 409, [
            ['C.6.1 浮動小数点パイプライン', 411],
            ['C.6.2 R4000パイプラインの性能', 413]
        ]],
        ['C.7 他の章との関連', 413, [
            ['C.7.1 RISC命令セットとパイプラインの効率', 413],
            ['C.7.2 動的スケジューリングパイプライン', 413]
        ]],
        ['C.8 誤った考えと落とし穴', 416],
        ['C.9 おわりに', 416],
        ['C.10 歴史展望と参考文献', 416],
        ['C.11 演習問題', 417]
    ]],
    ['参考文献', 421],
    ['索引', 441],
    ['その他の付録', 447, [
        ['コンピュータアーキテクチャの公式', 447],
        ['経験則', 447],
        ['本書で使われているCPUの用語とNVIDIAおよびOpenCL用語との対比', 448],
        ['RV64G命令サブセット', 449]
    ]],
    ['訳者あとがき', 450],
    ['奥付', 452],
    ['裏表紙', 453]
]

def add_outline(writer, outline, offset, parent = None):
    title = outline[0]
    page = outline[1]
    bookmark = writer.addBookmark(title, page + offset, parent)
    if len(outline) > 2:
        children = outline[2]
        for child in children:
            add_outline(writer, child, offset, bookmark)

def main():
    parser = argparse.ArgumentParser(
        prog='ca6fix',
        description="Fix some disappointmented points in Computer Architecture Quantitative Approach 6th Edition Japanese translation PDF file.",
        usage='ca6fix -i ca6.pdf -o ca6_fixed.pdf',
        add_help=True)
    parser.add_argument('-i', '--input', help='input PDF file', required=True)
    parser.add_argument('-o', '--output', help='output PDF file', required=True)
    args = parser.parse_args()

    reader = PdfFileReader(args.input)
    writer = PdfFileWriter()
    for p in range(reader.getNumPages()):
        page = reader.getPage(p)
        writer.addPage(page)

    writer.insertBlankPage(None, None, 4)

    for index in outline:
        add_outline(writer, index, 21)
    writer.setPageLayout('/TwoPageRight')
    writer.addMetadata({
        '/Title': 'コンピュータアーキテクチャ 定量的アプローチ［第6版］',
        '/Author': 'ジョン・L・ヘネシー, デイビッド・A・パターソン(著), 中條拓伯, 天野英晴, 鈴木　貢(訳)'
    })

    with open(args.output, 'wb') as fh:
        writer.write(fh)

if __name__ == '__main__':
    main()
